---
title: "Starting from netCDF files"
author: "G. Brooke Anderson"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: Anderson.bib
vignette: >
  %\VignetteIndexEntry{Starting from netCDF files}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

Climate model output files are available for CMIP5 in the netCDF file format. This vignette explains how files in this format can be opened and worked with in R to generate the required delimited format to use with the `futureheatwaves` package. 

## Downloading netCDF files for CMIP5

The Coupled Model Intercomparison Project is a key source of climate model output data for researchers studying the potential impact of climate change. This project is currently in its fifth phase (CMIP5). You can download netCDF files from CMIP5 from the World Climate Research Programme CMIP5 website at https://pcmdi.llnl.gov/search/cmip5/, hosted by the Department of Energy's Lawrence Livermore National Laboratory. The data is stored distributed across multiple data nodes at different institutions, but this and other data portals allow access to all available data through one website. You will need to register to download climate model output data. 

There are a number of parameters that can be used to search files, including:

- **"Institute"**: The climate modeling group that created the climate model. A list with the full names and IDs for each of these is available at http://cmip-pcmdi.llnl.gov/cmip5/docs/CMIP5_modeling_groups.pdf. Output from a few groups is restricted to non-commercial use. Several institutes have multiple models.
- **"Climate model"**: The name of the climate model used to produce the output. Chapter 9 of the Intergovernmental Panel on Climate Change (IPCC)'s Fifth Assessment Report provides an evaluation of climate models [available at https://www.ipcc.ch/pdf/assessment-report/ar5/wg1/WG1AR5_Chapter09_FINAL.pdf; @flato2013evaluation]. 
- **"Experiment"**: The scenario of external, time-varying values (e.g., greenhouse gas concentrations) that are input to the model. Standard experiments are "historical" (uses observed values from [year] to [year] as model inputs), [control-- "historicalMisc?"] (uses values from a scenario of pre-Industrial concentrations [?] from [year] to [year]), "rcp45" (uses concentrations based on a scenario of ... from [year] to [year]), and "rcp85" (uses concentrations based on a scenario of ... from [year] to [year]). For more information on the CMIP5 experiment design, see Taylor et al. [-@taylor2012overview] and  http://cmip-pcmdi.llnl.gov/cmip5/experiment_design.html. 
- **"Time frequency"**: The time step of model output (e.g., day, month, year)
- **"Ensemble"**: The ensemble member. Many climate models are run with multiple ensemble members, to allow exploration of uncertainty related to internal climate variability. For different ensemble member run for a climate model and experiment, the initial conditions are changed by a small amount, but the model and time-varying inputs are identical. The most common ensemble member is "ri1ip1". 
- **"Variable"**: The variable output by the model. Examples available at the near-surface include "tas" (near-surface air temperature), "tasmin" (daily minimum near-surface air temperature), "tasmax" (daily maximum near-surface air temperature), "hurs" (near-surface relative humidity), "pr" (precipitation). Explanations of variable abbreviations are available at http://cmip-pcmdi.llnl.gov/cmip5/docs/standard_output.pdf. 

You can download files from https://pcmdi.llnl.gov/search/cmip5/ using a point-and-click interface, but you can also use their ... [search API] to create a wget script that can be used to download many files at once and to later update files by only downloading those that have changed since the last download. These climate model output files can be very large, so be sure you have adequate disk space before downloading.

## Working with netCDF files in R

To try out the examples in this section, you will need to download the following climate model output file to your own computer from https://pcmdi.llnl.gov/search/cmip5/ [and have it in your current working directory?]: 

- tas_day_GFDL-ESM2G_historical_r1i1p1_19860101-19901231.nc

Three R packages--- `ncdf4`, `ncdf4.helpers`, and `PCICt`---provide useful tools for working with netCDF climate model output files. 

```{r message = FALSE, warning = FALSE}
library(ncdf4)
library(ncdf4.helpers)
library(PCICt)
```

Some of the standard tidyverse packages are also helpful and should be loaded to run the example code in this vignette: 

```{r message = FALSE, warning = FALSE}
library(readr)
library(dplyr)
library(tidyr)
library(ggplot2)
```

As an example, say you have a climate model output file saved locally called "tas_day_GFDL-ESM2G_historical_r1i1p1_19860101-19901231.nc". As a note, the CMIP5 file names encode information about the climate model output given in the file, including the variable (here, "tas", the near-surface air temperature), the experiment ("historical"), the dates covered by the output (Jan. 1, 1986 to Dec. 31, 1990), the climate model ("GFDL-ESM2G", from the NOAA Geophysical Fluid Dynamics Laboratory), the time step of the output ("day"), and the ensemble member ("r1i1p1").

You can use the `nc_open` function from the `ncdf4` package to open a connection to a netCDF file. The version of netCDF changed from version 3 to version 4 in 2008, and some R packages for netCDF files will only work with the older version 3, but the `ncdf4` package can work with either. 

```{r}
climate_filepath <- paste0("~/Downloads/tas_day_GFDL-ESM2G_historical",
                           "_r1i1p1_19860101-19901231.nc")
climate_output <- nc_open(climate_filepath)
```

The `nc_open` function opens a connection to the netCDF file, but does not read all the data in the file into memory. Instead, this function reads into memory some information about the file, and it opens a connection that can be used in conjunction with other commands to read in specific parts of the data. Once you no longer need the file connection, you should close the connection with `nc_close`.

If you print the object created by `nc_open`, you will get some metadata on the file, including the variables that are available in the file, which are used for dimensions, and what units each are in:

```{r}
climate_output
```

Once you know the names of variables in the file, you can use the `ncvar_get` function to read all values of that variable into an R object. For example, to get all the values of longitude and latitude in the example file, which define two of the dimensions of the array for the temperature values reported in the file, you can run:

```{r}
lon <- ncvar_get(climate_output, varid = "lon")
lat <- ncvar_get(climate_output, varid = "lat")

summary(lon)
summary(lat)
```

In addition to the longitude and latitude dimensions, the climate model output files also include a time dimension. The metadata for the file includes information on how this time is reported, which is typically in days since some origin date for climate model output. This information is included in the `$dim$time$units` element of the R object returns with `nc_open`:

```{r}
climate_output$dim$time$units
```

While the R function `as.Date` allows the user to specify an origin to compute a date, this function typically will not work correctly with climate model output files, as climate models often provide output using calendars other than the standard Gregorian calendar. Climate model output can be tied to a number of different calendars, including a "no-leap" calendar, which omits leap days from the calendar, a 360-day calendar, which uses 30-day months for all 12 months, and a number of other calendars. You can determine the calendar used to a netCDF file from the `$dim$time$calendar` element of the R object returns with `nc_open`:

```{r}
climate_output$dim$time$calendar
```

This use of non-standard calendars messes up the calculations of `as.Date`, so you must use a more specialized function to read in the time variable of the climate model output and map it to standard calendar dates. You can do this with the `nc.get.time.series` function from the `ncdf4.helpers` package (you should also load the `PCICt` package to use this function): 

```{r}
tas_time <- nc.get.time.series(climate_output, v = "tas",
                               time.dim.name = "time")
tas_time[c(1:3, length(tas_time) - 2:0)]
```

The longitude, latitude, and time variables define the dimensions for the climate model output, which for this file is the [tas] at a specific grid point (longitude, latitude) and day (time). You can read in this main variable using `ncvar_get`: 

```{r}
tas <- ncvar_get(climate_output, "tas")
```

This variable is in a 3-dimensional array, with dimensions ordered as first longitude, then latitude, then time: 

```{r}
dim(tas)
length(lon)
length(lat)
length(tas_time)
```

Once you have read all variables into R objects, you can close the file using: 

```{r}
nc_close(climate_output)
```

You can use indexing to pull the modeled temperature at a certain location and time step. For example, Beijing, China, is at latitude 39.9 degrees north and 116.4 degrees east. To get the value of the modeled temperature on July 7, 1986, at the model grid point closest to Beijing, you can run (the units on the output are Kelvin):

```{r}
lon_index <- which.min(abs(lon - 116.4))
lat_index <- which.min(abs(lat - 39.9))
time_index <- which(format(tas_time, "%Y-%m-%d") == "1986-07-01")
tas[lon_index, lat_index, time_index]
```

To get the full time series of modeled temperature at the grid point closest to Beijing, you can run: 

```{r fig.width = 6, fig.height = 3}
beijing_output <- data_frame(time = tas_time,
                             tas = tas[lon_index, lat_index, ]) %>%
        mutate(time = as.Date(format(time, "%Y-%m-%d")))
beijing_output %>%
        ggplot(aes(x = time, y = tas)) + 
        geom_point(alpha = 0.7) + 
        xlab("Date") + ylab("Temperature (K)")
```

Note that this code uses `format` and `as.Date` to convert the PCICt object to a date object, to allow use of a date axis when plotting with `ggplot2`.

To get the modeled temperature on July 1, 1986, at all grid point locations, you can run: 

```{r}
july_1_1986 <- tas[ , , time_index]
july_1_1986[1:3, 1:3]
```

This data is a two-dimensional matrix, where the column is specific to longitude and the row to latitude. To tidy this data to make it easier to map with `ggplot2`, you can use `expand.grid` to create a dataframe with every combination of longitude and latitude, and then use `as.vector` with the temperature values for July 1, 1986, to add temperature values at each of these longitudes and latitudes. Because the longitude dimension precedes the latitude dimension in the `tas` array, it should be put first in the `expand.grid` so that longitude and latitude values align correctly with the unlisted temperature data. Longitude should be mutated to have values between -180 and 180 (in the original data, it is between 0 and 360) to work better with `ggplot2` mapping. 

```{r}
all_coords <- expand.grid(lon, lat) %>%
        rename(lon = Var1, lat = Var2) %>%
        mutate(lon = ifelse(lon > 180, -(360 - lon), lon),
               tas = as.vector(july_1_1986))
```

This modeled temperature data for a single day can be mapped using `ggmap` and `ggplot2` functions (the `viridis` package is also used here for the color scale and the `weathermetrics` package to convert the temperature from Kelvin to Celsius):

```{r fig.width = 8, fig.height = 4, message = FALSE, warning = FALSE}
library(ggmap)
library(viridis)
library(weathermetrics)

all_coords %>% 
        mutate(tas = convert_temperature(tas, "k", "c")) %>%
        ggplot() + 
        borders("world", colour="gray50", fill="gray50") + 
        geom_point(aes(x = lon, y = lat, color = tas),
                   size = 0.5) + 
        scale_color_viridis(name = "Temperature (C)") + 
        theme_void() + 
        coord_quickmap() + 
        ggtitle("Modeled temperature on July 1, 1986",
                subtitle = "GFDL-ESM2G model, historical experiment, r1i1p1 ensemble member") 
```

### Working with other R packages

#### The `RCMIP5` package

Some functions only work with monthly or less frequent data (`checkTimePeriod`, `cmip5data`, functions that work with `cmip5data` objects like `filterDimensions` and `getProjectionMatrix`). The package's `getFileInfo` function, however, will work with CMIP5 files of any time step; this function identifies all CMIP5 files in a directory and creates a dataframe that parses the information contained in the file name. For example:

```{r}
library(RCMIP5)
getFileInfo("~/Downloads")
```

While the `loadCMIP5` function seems to load the daily data as a `cmip5data` object, it seems that most of the methods for this object type do not do anything meaningful for data at this time resolution.

#### The `wux` package

This package includes functions that allow the user to download CMIP5 monthly-aggregated output directly from within R with the `CMIP5fromESGF` function. However, this function does not allow downloading of climate model output with finer time steps, including daily data. 

Other functions in this pacakage similarly will only work for monthly climate model output, including `CMIP5toModelinput`

## Processing climate model output data to use with `futureheatwaves`

To try out the examples in this section, you will need to download the following climate model output files to your own computer from https://pcmdi.llnl.gov/search/cmip5/ [and have them in your current working directory?]: 

- tas_day_GFDL-ESM2G_historical_r1i1p1_19860101-19901231.nc
- tas_day_GFDL-ESM2G_historical_r1i1p1_19910101-19951231.nc
- tas_day_GFDL-ESM2G_rcp85_r1i1p1_20710101-20751231.nc
- tas_day_GFDL-ESM2G_rcp85_r1i1p1_20760101-20801231.nc

The `futureheatwaves` package requires that climate output files are in a certain output to be processed. The data in the climate model output netCDF must be saved in three files: one for time, one for grid point location (latitude and longitude), and one for the climate model output variable (e.g., temperature in the example file used in this case). The following code can be used to correctly format and save the data from the climate model output netCDF file in a way that will allow processing by the `futureheatwaves` package: 

```{r}
# Load required libraries
library(ncdf4)
library(ncdf4.helpers)
library(PCICt)
library(readr)
library(dplyr)
library(tidyr)

# Open connection to netCDF file, read in variables, and close connection
climate_filepath <- paste0("~/Downloads/tas_day_GFDL-ESM2G_",
                           "historical_r1i1p1_19860101-19901231.nc")
climate_output <- nc_open(climate_filepath)
lon <- ncvar_get(climate_output, "lon")
lat <- ncvar_get(climate_output, "lat")
tas_time <- nc.get.time.series(climate_output,
                               v = "tas", time.dim.name = "time")
tas <- ncvar_get(climate_output, "tas")
nc_close(climate_output)

# Change to appropriate format for futureheatwaves package
time_output <- data_frame(index = 1:length(tas_time),
                          time = format(tas_time, "%Y-%m-%d")) %>%
        separate(time, c("year", "month", "day")) %>%
        mutate(year = as.integer(year),
               month = as.integer(month),
               day = as.integer(day))
coordinate_output <- expand.grid(lon, lat) %>%
        rename("lon" = Var1) %>%
        rename("lat" = Var2) %>%
        select(lat, lon)
tas_output <- matrix(unlist(tas), 
                     ncol = length(lon) * length(lat),
                     byrow = TRUE) %>%
        as.data.frame()

# Save data as three comma-separated files
if(!dir.exists("~/tmp/dataFolder/historical/GFDL/r1i1p1")){
        dir.create("~/tmp/dataFolder/historical/GFDL/r1i1p1",
                   recursive = TRUE)
}
write_csv(time_output, 
          path = "~/tmp/dataFolder/historical/GFDL/r1i1p1/time_day.csv",
          col_names = FALSE)
write_csv(coordinate_output, 
          path = "~/tmp/dataFolder/historical/GFDL/r1i1p1/latitude_longitude_day.csv", 
          col_names = FALSE)
write_csv(tas_output,
          path = "~/tmp/dataFolder/historical/GFDL/r1i1p1/tas_day.csv",
          col_names = FALSE)
```

If you are only using this dataset and do not also have a future experiment to include, you should create a "dummy" rcp85 folder to get the `futureheatwaves` functions to run correctly. To do this, you can just save the same files in an `rcp` subdirectory: 

```{r}
if(!dir.exists("~/tmp/dataFolder/rcp85/GFDL/r1i1p1")){
        dir.create("~/tmp/dataFolder/rcp85/GFDL/r1i1p1",
                   recursive = TRUE)
}
write_csv(time_output, 
          path = "~/tmp/dataFolder/rcp85/GFDL/r1i1p1/time_day.csv",
          col_names = FALSE)
write_csv(coordinate_output, 
          path = "~/tmp/dataFolder/rcp85/GFDL/r1i1p1/latitude_longitude_day.csv", 
          col_names = FALSE)
write_csv(tas_output,
          path = "~/tmp/dataFolder/rcp85/GFDL/r1i1p1/tas_day.csv",
          col_names = FALSE)
```

The data can now be processed by the `futureheatwaves` package. For example, to identify and characterize all heatwaves between 1986 and 1990 at the cities listed in the "cities.csv" file that comes with the package:

```{r}
library(futureheatwaves)
city_file_location <- system.file("extdata/chinese_cities.csv",
                                 package = "futureheatwaves")
gen_hw_set(out = "~/tmp/example_results",
           dataFolder = "~/tmp/dataFolder",
           dataDirectories = list("historical" = c(1986, 1990),
                                  "rcp85" = c(2060, 2079)),
           citycsv = city_file_location,
           coordinateFilenames = "latitude_longitude_day.csv",
           tasFilenames = "tas_day.csv",
           timeFilenames = "time_day.csv",
           thresholdBoundaries = c(1986, 1990),
           projectionBoundaries = c(1986, 1990),
           referenceBoundaries = c(1986, 1990),
           printWarning = FALSE)
```

You can then work with this output as with any output from `gen_hw_set`. For example, you can create a plot of city and matching grid point locations using:

```{r message = FALSE, fig.width = 6, fig.height = 6}
out <- "~/tmp/example_results"
map_grid_ggmap(plot_model = "GFDL", out = out)
```

You can use `apply_all_models` to apply functions to explore the heatwave output. For example, you can determine the number of heatwaves in each community and the average temperature of heatwaves in each community using: 

```{r}
library(forcats)
apply_all_models(out = out, FUN = number_of_heatwaves,
                 city_specific = TRUE) %>%
        mutate(city = fct_reorder(city, value)) %>%
        ggplot(aes(x = city, y = value)) + 
        geom_bar(stat = "identity") + 
        coord_flip() + 
        theme_classic() + 
        ylab("# of heatwaves") + 
        xlab("")
```

```{r fig.height = 4, fig.width = 4}
apply_all_models(out = out, FUN = average_mean_temp,
                 city_specific = TRUE) %>%
        mutate(value = convert_temperature(value, "k", "c")) %>%
        mutate(city = fct_reorder(city, value)) %>%
        ggplot(aes(x = value, y = city)) + 
        geom_point() +  
        ylab("") + 
        xlab(expression(paste("Average temperature during heatwaves (",
                              degree*C, ")")))
```

## References
