#' Process valid models
#'
#' Process models that are valid and store information about the models
#' that have been written.
#'
#' @param model Character string of the climate model (e.g., "bcc1").
#' @param global List of global parameters generated by listGlobal.
#' @param custom List of custom parameters generated by listCustom.
#' @param accumulators Closures ... generated by createAccumulators
#'
#' @return [What does this function return?]
processModel <- function(model, global, custom, accumulators){

        # Get reference period if one exists
        reference <- custom["processModel"]

        # Acquire vector of threshold temperatures using the historical
        # ensemble for this model which possesses the name r1i1p1
        ret <- processHistorical(model, global, custom, reference)
        thresholds <- ret[[1]]
        reference <- ret[[2]]

        # Acquire characteristics of each RCP 8.5 ensemble of the model
        modelName <- model[[1]]
        ensembles <- model[[3]]
        rcpEnsembles <- lapply(ensembles,
                               processRCP,
                               modelName,
                               createEnsembleWriter(modelName, global, custom),
                               thresholds,
                               global,
                               custom,
                               accumulators,
                               reference)

        # Add entry to the modelInfoAccumulator
        accumulators("append model information", data.frame(modelName, length(rcpDirs)))

        return(rcpEnsembles)
}

#' Calculate threshold temperatures from historical projections
#'
#' Calculate the threshold temperatures for the model using the
#' model's r1i1p1 historical ensemble and saves these to file.
#'
#' @param model Character string of the climate model (e.g., "bcc1").
#' @param global List of global parameters generated by listGlobal.
#' @param custom List of custom parameters generated by listCustom.
#' @param reference [What is this parameter?]
#'
#' @return Writes threshold temperatures to file and returns ... ?
processHistorical <- function(model, global, custom, reference = FALSE){
        name <- model[[1]]
        historicalDirs <- model[[2]][1][[1]]
        cat("Processing historical ensemble for", name, "\n")

        # Acquire characteristics of the first historical ensemble
        historicalEnsemble <- processEnsemble(historicalDirs, 'historical', name, global, custom, reference)

        # Calculate threshold temperatures
        thresholds <- apply(historicalEnsemble$series, 2, quantile, probs = .98)

        # Acquire the reference series. Will be false if reference period unspecified
        reference_series <- historicalEnsemble$reference

        # Save thresholds to file
        writeThresholds(name, 'thresholds', thresholds, global, custom)

        ret <- list(thresholds, reference_series)
        return(ret)
}

#' Create heatwave dataframe for climate projection
#'
#' For each reference ensemble, create the heatwave dataframe and
#' write it to file. Also store the locations  vector for each ensemble.
#'
#' @param ensemble
#' @param modelName
#' @param ensembleWriter
#' @param thresholds
#' @param global List of global parameters generated by listGlobal.
#' @param custom List of custom parameters generated by listCustom.
#' @param accumulators Closures ... generated by createAccumulators
#' @param reference [What is this parameter?]
#'
#' @return Write every heatwave dataframe to a .csv and return the ensemble
#'    used as the reference.
processRCP <- function(ensemble, modelName, ensembleWriter, thresholds,
                       global, custom, accumulators, reference = FALSE){
        cat("Processing rcp 8.5 ensemble", modelName, "\n")

        # Acquire desired characteristics of the RCP 8.5 ensembles
        ensemble <- processEnsemble(ensemble, 'rcp', modelName, global,
                                    custom, reference)

        # Append locations vector to the locations vector accumulator
        accumulators("append location list", ensemble$locations)

        # Acquire the heatwave dataframes for every rcp 8.5 ensemble in this model
        hwFrame <- formHwFrame(ensemble, thresholds, global, custom)

        # Write every heatwave frame to a .csv
        ensembleWriter(hwFrame)

        # Return the ensemble used as the reference
        return(ensemble)
}

#' Extract the desired data out of the ensemble
#'
#' Extract the desired climate data out of a single ensemble member of
#' the climate model's projections.
#'
#' @param ensemble Character string that gives the absolute file path
#'    for the directory with a particular ensemble member of a climate
#'    model projection.
#' @param experiment Character string of the experiment of interest.
#'    Possible variables are "historical" or "rcp85".
#' @param modelName [What is this?]
#' @param global List of global parameters generated by listGlobal.
#' @param custom List of custom parameters generated by listCustom.
#' @param reference [What is this parameter?]
#'
#' @return Returns a list with...
processEnsemble <- function(ensemble, experiment, modelName, global,
                            custom, reference){

        # Read the ensemble data
        cat("Reading --->", ensemble[1], "\n")
        latlong <- readLatLong(ensemble)
        tas <- readtas(ensemble)
        times <- readTimes(ensemble)
        cat("Read operation complete", "\n")

        # Find indices of the closest points of measurement
        locations <- apply(global$cities, 1, closest_point, latlong = latlong)

        # Acquire the boundaries for the time series
        # Structure: c(start index, end index, # of elements spanning
        # from start to end)
        bounds <- getBounds(times, experiment, custom)
        start <- bounds[1]
        end <- bounds[2]
        
        #         if(debug){
        #                 print("Process Ensemble Bounds: ")
        #                 cat("start: ", start, "\n")
        #                 cat("end: ", end, "\n")
        #         }
        bloodhound <<- ensemble
        bark <<- times
        hold <<- tas
        
        subCustom <- list("IDheatwaves" = FALSE,
                          "getBounds" = reference,
                          "processModel" = FALSE,
                          "createHwDataframe" = FALSE)
        # Get a vector containing the dates of days we are dealing with
        dates <- formDates(times, bounds)
        
        # Acquire time series for every city
        series <- data.frame(tas[start:end, locations])

        # Convert the time series data to Fahrenheit
        series <- apply(series, 1:2, function(element) {
                return((element * 9/5) - 459.67)
        })

        # CUSTOM BLOCK
        # Extract and store the reference period data
        if(reference != FALSE && length(reference) != 1){
                rbounds <- getBounds(times, experiment, subCustom)
                reference <- data.frame(tas[rbounds[1]:rbounds[2], locations])
                reference <- apply(series, 1:2, function(element){
                        return((element * 9/5) - 459.67)
                })
        }

        # Prepare return value
        ret <- list(locations = locations,
                    bounds = bounds,
                    series = series,
                    times = times,
                    dates = dates,
                    reference = reference)
        return(ret)
}

#' Find closest grid point to a city location
#'
#' Identify the closest grid points for a climate model to a
#' city based on the city's latitude and longitude. Use the
#' Pythagorean theorem.
#'
#' @param city A numeric vector containing the city's ID, latitude, and
#'    longitude, in that order.
#' @param latlong A dataframe of latitude and longitude pairings for each
#'    climate grid cell location, with latitudes in the first column and
#'    longitudes in the second column.
#'
#' @return An index corresponding to the coordinates in the dataframe
#'    that is closest to the city coordinates.
closest_point <- function(city, latlong){
        latitude <- as.double(city[2])
        longitude <- 360 - as.double(city[3])
        aSQ <- abs(latlong[,1] - latitude) ^ 2
        bSQ <- abs(latlong[,2] - longitude) ^ 2
        cSQ <- aSQ + bSQ
        c <- sqrt(cSQ)
        smallest <- min(c)
        index <- match(smallest, c)
        return(index)
}

#' Acquire boundaries of time series data
#'
#' @param times A dataframe containing the time data for one of the
#'    climate model ensemble's projection.
#' @param experiment experiment Character string of the experiment of
#'    interest. Possible variables are "historical" or "rcp85".
#' @param custom [What is this?]
#'
#' @return A numeric vector containing an upper bound of the experiment
#'    time period as an index; the lower bound of the experiment time
#'    period as an index; and the number of days spanned.
#'    Format: c(start, end, size)
#'
#' @note This function is customizable.
# TODO: See if it is possible to simplify this function by using data from the global carrier instead
# of custom
getBounds <- function(times, experiment, custom){
        # Set boundaries
        start <- 0
        end <- 0
        if (experiment == 'historical'){
                if(custom["getBounds"] == FALSE){
                        start <- match(1981, times[,2])

                        #'end' index of the historical experiment has to be matched from back to front.
                        # This is because the data does/may not exceed year 2005.
                        # We wish to set the end bound to the first day of 2004 instead.
                        # The match function alone will acquire the index of the first day of 2004,
                        # even though we want all days in 2004.
                        end <- length(times[,1]) - (match(2004, rev(times[,2])) - 1)

                } else {
                        customizeHistorical <- custom["getBounds"]
                        lower <- customizeHistorical[1]
                        upper <- customizeHistorical[2]
                        start <- match(lower, times[,2])
                        end <- length(times[,1]) - (match(upper, rev(times[,2])) - 1)
                }
        } else if (experiment == 'rcp'){
                if(custom["getBounds"] == FALSE){
                        start <- match(2061, times[,2])
                        end <- match(2081, times[,2]) - 1
                } else {
                        customizeRCP <- custom["getBounds"]
                        lower <- customizeRCP[3]
                        upper <- customizeRCP[4]
                        start <- match(lower, times[,2])
                        end <- match((upper + 1), times[,2]) - 1
                }
        }
        size <- end - (start - 1)
        return(c(start, end, size))
}

#' Determine dates for the requested time period.
#'
#' Acquire the dates spanning the desired time period of the ensemble
#'
#' @param times A dataframe containing the time data for one of the
#'    climate model ensemble's projection.
#' @param bounds A numeric vector with the desired time boundaries of the
#'    ensemble.
#'
#' @return A vector of dates formatted as year-month-day (%Y-%m-%d) spanning
#'    the desired time boundaries.
formDates <- function(times, bounds){
        start <- bounds[1]
        end <- bounds[2]
        dateComponents <- data.frame(times[start:end, 2:4])
        dates <- paste(dateComponents[,1],
                       dateComponents[,2],
                       dateComponents[,3],
                       sep = "-")
        dates <- as.Date(dates)
        return(dates)
}
