#' Create heatwave dataframe for the given ensemble
#'
#' @param ensembleSeries A list object giving the projection times series as
#'    well as a variety of other information for a single ensemble member.
#'    This is the output of \code{\link{processEnsemble}}.
#' @inheritParams processRCP
#' @inheritParams processModel
#'
#' @return The combined dataframe of identified and characterized heatwaves for
#'    selected projection date range for all communities specified by the user.
formHwFrame <- function(ensembleSeries, thresholds, global, custom){
        # Acquire list of heatwave dataframes for each city
        hwDataframeList <- apply(data.frame(thresholds), 1,
                                 createCityProcessor(global = global),
                                 ensembleSeries = ensembleSeries,
                                 custom = custom)

        # Combine the heatwave dataframes contained in hwDataframeList into
        # a single dataframe
        hwFrame <- consolidate(hwDataframeList)

        return(hwFrame)
}

#' Identify and aggregate heatwaves for a particular city
#'
#' @inheritParams processModel
#'
#' @return A closure that will find all heatwaves for a given ensemble. Each
#'    passed threshold corresponds to a particular city. The closure advances
#'    an incrementer every time it is called to get this effect.
#'    Argument 1: A threshold temperature
#'    Argument 2: The ensemble from which you wish to find heatwaves.
#'
#' @note The closure encapsulates an incrementer varaible and advances it
#'    with every call. This variable is used to index into the cities vector
#'    from the "global" data list.
#'
#' The closure created by this function takes the parameters \code{threshold},
#'    \code{ensembleSeries}, and \code{custom}. The closure returns a
#'    dataframe with the identified heatwaves and heatwave characteristics for
#'    a given city for the specified projection period, as generated by the
#'    \code{createHwDataframe} function.
# TODO: There is a redefinition of the custom variable. Test if it is necessary.
# TODO: Add documentation of the format of the return value
# TODO: Eventually, figure out if there is an elegant way of getting the corresponding city without the need for a closure
# to increment over the cities list.
createCityProcessor <- function(global){
        # incrementer
        i <- 1

        function(threshold, ensembleSeries, custom){
                city <- as.character(global$cities[i,1])
                cat("Creating heatwave dataframe ~~ City: ", city,
                    " ~~ City Number: ", i, " ~~ Cutoff: ", threshold, "\n")

                datafr <- data.frame(ensembleSeries$dates,
                                     ensembleSeries$series[,i])

                # Identify all heatwaves for the given city
                heatwaves <- IDheatwaves(city = city,
                                         threshold = threshold,
                                         days = 2,
                                         datafr = datafr,
                                         global = global,
                                         custom = custom)

                # Aggregate heatwaves for the given city
                hwDataframeList <- createHwDataframe(city = city,
                                                     threshold = threshold,
                                                     heatwaves = heatwaves,
                                                     ensembleSeries = ensembleSeries,
                                                     i = i,
                                                     global = global,
                                                     custom = custom)

                i <<- i + 1
                return(hwDataframeList)
        }
}

#' Combine all identified heatwave dataframes together into one.
#'
#' @param hwDataframeList A list object where each element is the dataframe
#'    of identified and characterized heatwaves, created by
#'    the closure created by \code{\link{createCityProcessor}},
#'    for a single community .
#'
#' @return A combined dataframe version of the list that was passed as an
#'    argument.
consolidate <- function(hwDataframeList){
        all <- hwDataframeList[[1]]
        for(i in 2:length(hwDataframeList)){
                all <- rbind(all, hwDataframeList[[i]])
        }
        return(all)
}

#' Characterize heatwaves
#'
#' @param heatwaves data.frame(dates, thresholds)
#' @param i An index specifying with community of the specified communities
#'    is being processed. This corresponds to the order that the communities
#'    are given in the \code{citycsv} file specified in
#'    \code{\link{gen_hw_set}}.
#' @inheritParams processModel
#' @inheritParams formHwFrame
#' @inheritParams IDheatwaves
#'
#' @return Result is a dataframe where each row represents a heatwave.
#'
#' @importFrom dplyr %>%
createHwDataframe <- function(city = stop("Unspecified city"),
                              threshold = stop("Unspecified threshold"),
                              heatwaves = stop("'heatwaves' unspecified"),
                              ensembleSeries, i, global, custom){
        hold <<- heatwaves

        intermediate <- heatwaves
        heatwaves2 <- subset(intermediate, hw == 1)

        if(custom["createHwDataframe"] != FALSE){
                datafr <- data.frame(ensembleSeries$dates,
                                     ensembleSeries$reference[,i])
                heatwaves <- IDheatwaves(city = city,
                                         threshold = threshold,
                                         days = 2,
                                         datafr = datafr,
                                         global = global,
                                         custom = custom)
        }

        bloodhound <<- heatwaves2
        bark <<- heatwaves

        hw.frame <- dplyr::group_by(heatwaves2, hw.number) %>%
                dplyr::summarize(mean.temp = mean(tmpd),
                                 max.temp = max(tmpd),
                                 min.temp = min(tmpd),
                                 length = length(unique(date)),
                                 start.date = date[1],
                                 end.date = date[length(date)],
                                 start.doy = as.POSIXlt(date[1])$yday,
                                 start.month = as.POSIXlt(date[1])$mon + 1,
                                 days.above.80 = length(date[tmpd > 80]),
                                 days.above.85 = length(date[tmpd > 85]),
                                 days.above.90 = length(date[tmpd > 90]),
                                 days.above.95 = length(date[tmpd > 95]),
                                 days.above.99th = length(date[tmpd > quantile(heatwaves$tmpd, .99, na.rm = TRUE)]),
                                 days.above.99.5th = length(date[tmpd > quantile(heatwaves$tmpd, .995, na.rm = TRUE)]))

        hw.frame$first.in.season <- c(1, rep(NA, nrow(hw.frame) - 1))
        for(i in 2:nrow(hw.frame)){
                if(as.POSIXlt(hw.frame$start.date)$year[i] !=
                   as.POSIXlt(hw.frame$start.date)$year[i - 1]){
                        hw.frame$first.in.season[i] <- 1
                } else {
                        hw.frame$first.in.season[i] <- 0
                }
        }

        hw.frame$"98th.temp" <- threshold

        dist.tmpd <- ecdf(heatwaves$tmpd)
        hw.frame$mean.temp.quantile <- dist.tmpd(hw.frame$mean.temp)
        hw.frame$max.temp.quantile <- dist.tmpd(hw.frame$max.temp)
        hw.frame$min.temp.quantile <- dist.tmpd(hw.frame$min.temp)

        hw.frame$mean.temp.1 <- mean(heatwaves$tmpd)
        summertime <- as.POSIXlt(heatwaves$date)$mon %in% c(4:8)
        hw.frame$mean.summer.temp <- mean(heatwaves$tmpd[summertime])

        hw.frame$city <- city

        return(hw.frame)
}

