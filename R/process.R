# TODO: clarify documentation. Do this after testing.

#' Process valid models
#'
#' This function takes any models that are valid, identifies and characterizes
#' heatwaves within projections for each of its ensemble members, writes
#' those dataframes of heatwave projections out to the user-specified output
#' directory, and stores information about the models that have been written
#' to the output directory using the closure, \code{accumulators}, created by
#' \code{\link{createAccumulators}}.
#'
#' @param model List with parsed information about the directory structure for
#'    a specific climate model from the user-specified projections directory.
#'    This list is a subset of the list generated by
#'    \code{acquireDirectoryStructure}.
#' @param global An object name for the 'global' variable list. This
#'    parameter is passed through from \code{\link{gen_hw_set}} and includes user
#'    specifications for the path to the output directory, the path to the
#'    input climate projections, the dataframe with community locations, the
#'    format for the filenames of the coordinate, tas, and time files in the
#'    ensemble-specific subdirectories of the projection directory input by
#'    the user, and whether the user prefers to run the function using the R
#'    or C++ version of the function to identify heatwaves.
#' @param custom An object name for the 'custom` data list. This parameter is
#'    passed through from \code{\link{gen_hw_set}} and includes user specifications
#'    for, if specified as other than the default, an alternative function to
#'    use to identify heatwaves, alternative upper and lower year boundaries
#'    for the projection period of the heatwave datasets being generated,
#'    alternative upper and lower year boundaries for the reference period
#'    to be used when measuring all heatwave characteristics related to
#'    relative, rather than absolute, temperature, and the percentile
#'    threshold to use when defining heatwaves.
#' @param accumulators An object name for the closure generated by
#'    \code{\link{createAccumulators}}.
#'
#' @return A list object with the following elements: \code{locations}:
#'    A vector with the indices of the column of \code{tas} giving the
#'    climate projections for the climate grid point closest to each
#'    of the user-specified communities; \code{bounds}: indices linking
#'    the selected time bounds to the corresponding rows in the climate
#'    projection datafile, \code{tas} (first two values in the vector) as
#'    well as the total number of days within the range (third value);
#'    \code{series}: The climate projection data for the selected
#'    communities and time range. Each row corresponds to a different date;
#'    each column corresponds to a different community; \code{times}:
#'    A dataframe with the dates corresponding to each row of \code{series};
#'    \code{dates}: A vector with the dates, in Date format, corresponding
#'    to each row in \code{series}; \code{reference}: ... .
processModel <- function(model, global, custom, accumulators){

        # Acquire characteristics of each experiment of the model
        modelName <- model[[1]]
        histens <- model[[2]]
        rcpens <- model[[3]]

        # Get reference period if one exists
        reference <- custom["processModel"] # referenceBoundaries argument
                                            # from `gen_hw_set`

        # Acquire vector of threshold temperatures using the historical
        # ensemble for this model which possesses the name r1i1p1
        ret <- processThresholds(model, global, custom, reference)
        thresholds <- ret[[1]]
        reference <- ret[[2]]

        # Process the projection data

        # First, check whether this should process files from the "historical"
        # or the "rcp85" directory for the model
        if(custom$getBounds[3] < 2005){
                proj_ens <- histens
        } else {
                proj_ens <- rcpens
        }

        # Process the projection data for the files in the relevant directory
        rcpEnsembles <- lapply(proj_ens,
                               processProjections,
                               modelName = modelName,
                               ensembleWriter = createEnsembleWriter(modelName,
                                                                     global,
                                                                     custom),
                               thresholds = thresholds,
                               global = global,
                               custom = custom,
                               accumulators = accumulators,
                               reference = reference)

        # Add entry to the modelInfoAccumulator
        accumulators(command = "append model information",
                     newElement = data.frame(modelName,
                                             length(histens),
                                             length(rcpens)))

        return(rcpEnsembles)
}

#' Calculate threshold temperatures
#'
#' This function calculates the threshold temperatures required to identify
#' heatwaves in the climate projection data using each climate model's
#' first listed historical ensemble. These values are both used in later
#' functions to identify heatwaves in the projections and are also saved
#' to file through this function to have for future reference.
#'
#' @param reference FALSE, if the user has not specified custom reference
#'    boundaries through the \code{referenceBoundaries} argument in
#'    \code{\link{gen_hw_set}}, otherwise a vector with four elements
#'    (earliest historical year, latest historical year,
#'    earliest future projection year, latest future projection year)
#'    giving the user-specified custom date boundaries for the
#'    heatwave projections.
#' @inheritParams processModel
#'
#' @return A list with two elements: (1) a vector with one element for
#'    each community included in the user-specified community location
#'    file, with each element value giving the threshold temperature for the
#'    heatwave definition for a community, in the same order that communities
#'    are listed in the user-specificed \code{citycsv} file and (2) a
#'    \code{processModel} object, which is FALSE if the user did not
#'    specify custom year boundaries with \code{dataBoundaries} in
#'    \code{\link{gen_hw_set}} and otherwise is ... .
#'    This function also writes threshold temperatures to files within
#'    the user-specified output directory for future reference.
processThreshold <- function(model, global, custom, reference = FALSE){
        name <- model[[1]]

        # Determine relevant experiment for thresholds
        if(custom$getBounds[1] < 2005){
                experiment <- "historical"
        } else {
                experiment <- "rcp"
        }

        # To find the threshold, use the first ensemble member within
        # the relevant directory, historical or rcp
        if(experiment == "historical"){
                thresholdDirs <- model[[2]][1][[1]]
        } else {
                thresholdDirs <- model[[3]][1][[1]]
        }

        cat("Processing thresholds for", name, "\n")

        # Acquire characteristics of the first historical ensemble
        thresholdEnsemble <- processEnsemble(ensemble = thresholdDirs,
                                              experiment = experiment,
                                              modelName = name,
                                              global = global,
                                              custom = custom,
                                              reference = reference)

        # Calculate threshold temperatures using the user-specified
        # threshold percentile (default: 0.98)
        thresholds <- apply(thresholdEnsemble$series, 2, quantile,
                            probs = custom$probThreshold)

        # Acquire the reference series. Will be false if reference period
        # unspecified
        reference_series <- historicalEnsemble$reference

        # Save thresholds to file
        writeThresholds(name, 'thresholds', thresholds, global, custom)

        ret <- list(thresholds, reference_series)
        return(ret)
}

#' Create heatwave dataframe for climate projection
#'
#' For each reference ensemble, create the heatwave dataframe and
#' write it to file. Also store the locations  vector for each ensemble.
#'
#' @param ensemble List with parsed information about the directory structure for
#'    a specific ensemble member from the user-specified projections directory.
#'    This list is a subset of the list generated by
#'    \code{\link{acquireDirectoryStructure}}.
#' @param ensembleWriter A closure created by \code{createEnsembleWriter} to
#'    write output from this process to a file within the output directory
#'    specified by the user.
#' @param thresholds A vector with the thresholds to use within each community
#'    in that community's heatwave definition.These are typically automatically
#'    determine during the run of the \code{gen_hw_set} function based on
#'    historical climate projections within the community.
#' @inheritParams buildStructureModels
#' @inheritParams processModel
#' @inheritParams processHistorical
#'
#' @return Write every heatwave dataframe to a .csv and return the ensemble
#'    used as the reference.
processProjections <- function(ensemble, modelName, ensembleWriter, thresholds,
                       global, custom, accumulators, reference = FALSE){
        cat("Processing projections for ", modelName, "\n")

        # Determine if `experiment` is `historical` or `rcp85`
        if(custom$getBounds[3] < 2005){
                experiment <- "historical"
        } else {
                experiment <- "rcp"
        }

        # Acquire desired characteristics of the RCP 8.5 ensembles
        ensembleSeries <- processEnsemble(ensemble = ensemble,
                                    experiment = experiment,
                                    modelName = modelName,
                                    global = global,
                                    custom = custom,
                                    reference = reference)

        # Append locations vector to the locations vector accumulator
        accumulators("append location list", ensembleSeries$locations)

        # Acquire the heatwave dataframes for every ensemble in the
        # model
        hwFrame <- formHwFrame(ensembleSeries = ensembleSeries,
                               thresholds = thresholds,
                               global = global,
                               custom = custom)

        # Write every heatwave frame to a .csv
        ensembleWriter(hwFrame)

        # Return the ensemble used as the reference
        return(ensemble)
}

#' Extract projections from ensemble member
#'
#' This function extract the desired climate data out of a single ensemble
#' member of the climate model's projections either from a historical or
#' future projection.
#'
#' To do this, the function (1) reads in the latitude
#' and longitude data from the grid location file for the ensemble member;
#' (2) reads in the climate projection data for the ensemble member; (3)
#' reads in the time file for the ensemble member; (4) finds the closest
#' grid point in the climate model grid for each community in the
#' \code{citycsv} file provided by the user; (5) ...
#'
#' @inheritParams processModel
#' @inheritParams buildStructureExperiments
#' @inheritParams buildStructureModels
#' @inheritParams processHistorical
#' @inheritParams processRCP
#'
#' @return Returns a list with the following:
#'    \code{locations}: A numberical vector with the indices of the columns
#'    in \code{tas} that correspond to the closest grid point in the climate
#'    model for each of the selected cities;
#'    \code{bounds}: Numerical vector of length three with the row number
#'    in the \code{tas} dataset corresponding to the first date in the
#'    selected time frame, the last date in the time frame, and the total
#'    number of days of data between the starting and ending date
#'    boundaries;
#'    \code{series}: Data with the climate projections by day in the time
#'    series (row) and community of analysis (column);
#'    \code{times}: Vector of row in \code{tas}, year, month, and day of
#'    all observations in the \code{tas} data;
#'    \code{dates}: Vector of Date class with all the dates in the selected
#'    time period;
#'    \code{reference}: Either FALSE, if the ensemble was not drawn using
#'    a custom time frame, or ...
#'
#' @note This function calls another function that uses the Pythagorean
#'    theorem to calculate the distance between each community given in the
#'    \code{citycsv} file and the nearest grid point for the climate model
#'    for the specified ensemble member.
processEnsemble <- function(ensemble, experiment, modelName, global,
                            custom, reference){

        # Read the ensemble data
        cat("Reading --->", ensemble[1], "\n")
        latlong <- readLatLong(ensemble)
        tas <- readtas(ensemble)
        times <- readTimes(ensemble)
        cat("Read operation complete", "\n")

        # Find indices of the closest points of measurement
        locations <- apply(global$cities, 1, closest_point, latlong = latlong)

        # Acquire the boundaries for the time series
        # Structure: c(start index, end index, # of elements spanning
        # from start to end)
        bounds <- getBounds(times = times,
                            experiment = experiment,
                            custom = custom)
        start <- bounds[1]
        end <- bounds[2]

        #         if(debug){
        #                 print("Process Ensemble Bounds: ")
        #                 cat("start: ", start, "\n")
        #                 cat("end: ", end, "\n")
        #         }

        subCustom <- list("IDheatwaves" = FALSE,
                          "getBounds" = reference,
                          "processModel" = FALSE,
                          "createHwDataframe" = FALSE)
        # Get a vector containing the dates of days we are dealing with
        dates <- formDates(times, bounds)

        # Acquire time series for every city
        series <- data.frame(tas[start:end, locations])

        # Convert the time series data to Fahrenheit
        series <- apply(series, 1:2, function(element) {
                return((element * 9/5) - 459.67)
        })

        # CUSTOM BLOCK
        # Extract and store the reference period data
        if(reference != FALSE && length(reference) != 1){
                rbounds <- getBounds(times = times,
                                     experiment = experiment,
                                     custom = subCustom)
                reference <- data.frame(tas[rbounds[1]:rbounds[2], locations])
                reference <- apply(reference, 1:2, function(element){
                        return((element * 9/5) - 459.67)
                })
        }

        # Prepare return value
        ret <- list(locations = locations,
                    bounds = bounds,
                    series = series,
                    times = times,
                    dates = dates,
                    reference = reference)
        return(ret)
}

#' Find closest grid point to a city location
#'
#' This function identifies the closest grid points in a climate model to a
#' community based on the community's latitude and longitude using the
#' Pythagorean theorem.
#'
#' @param city A numeric vector containing the city's ID, latitude, and
#'    longitude, in that order.
#' @param latlong A dataframe of latitude and longitude pairings for each
#'    climate grid cell location, with latitudes in the first column and
#'    longitudes in the second column.
#'
#' @return An index corresponding to the column in the climate projections
#'    dataframe for that climate model that is closest to the city
#'    coordinates.
closest_point <- function(city, latlong){
        latitude <- as.double(city[2])
        longitude <- 360 - as.double(city[3])
        aSQ <- abs(latlong[,1] - latitude) ^ 2
        bSQ <- abs(latlong[,2] - longitude) ^ 2
        cSQ <- aSQ + bSQ
        c <- sqrt(cSQ)
        smallest <- min(c)
        index <- match(smallest, c)
        return(index)
}

#' Acquire boundaries of time series data
#'
#' @param times A dataframe containing the time data for one of the
#'    climate model ensemble's projection. Each row in this dataframe
#'    corresponds to the row with the same row number in the climate
#'    projection dataframe. Read in by
#'    \code{\link{processEnsemble}}.
#' @inheritParams buildStructureExperiments
#' @inheritParams processModel
#'
#' @return A numeric vector containing the number of days spanned by the
#'    time period, the lower bound of the experiment time
#'    period as an index specifying the relevant row of the climate projection
#'    data; and an upper bound of the experiment time period as an index
#'    specifying the relevant row of the climate projection data.
#'
#' @note This function is customizable. If data boundaries are not set
#'    using \code{dataBoundaries} in the \code{\link{gen_hw_set}} function call,
#'    the default is to pull Jan. 1, 1981, to Dec. 31, 2014 for a
#'    historical experiment and Jan. 1, 2061 to Dec. 31, 2080 for
#'    a future projection experiment.
#'
# TODO: See if it is possible to simplify this function by using data from
# the global carrier instead of custom
getBounds <- function(times, custom, type){
        # Set boundaries

        if(type == "threshold"){
                start_time <- custom$getBounds[1]
                end_time <- custom$getBounds[2] + 1
        } else if (type == "projections") {
                start_time <- custom$getBounds[3]
                end_time <- custom$getBounds[4] + 1
        } else if (type == "reference"){
                start_time <- custom$processModel[1]
                end_time <- custom$processModel[2] + 1
        }

        start <- match(start_time, times[,2])
        end <- match(end_time, times[,2]) - 1
        size <- end - (start - 1)

        return(c(start, end, size))
}

#' Create date vector for requested time period
#'
#' Create a vector that includes all the dates spanning the requested
#' date range.
#'
#' @param bounds A numeric vector with the desired time boundaries of the
#'    ensemble, in terms of indices referring to the first and last row
#'    in the climate projection data frame within the requested date range.
#' @inheritParams getBounds
#'
#' @return A vector of dates formatted as year-month-day (%Y-%m-%d) spanning
#'    the desired time boundaries.
formDates <- function(times, bounds){
        start <- bounds[1]
        end <- bounds[2]
        dateComponents <- data.frame(times[start:end, 2:4])
        dates <- paste(dateComponents[,1],
                       dateComponents[,2],
                       dateComponents[,3],
                       sep = "-")
        dates <- as.Date(dates)
        return(dates)
}
